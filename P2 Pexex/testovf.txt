gcc -O2 -S test.c

"xorl %eax %eax" zeroes the eax register. "rax" is where the result is returned. 0 is false. n+1<n should logically be false for all n, so compiler optimizes for this. If n>0, it overflows and the behavior is undefined so it can do anything. If n<=0, the statement always evaluates to false.

        .file   "test.c"
        .text
        .p2align 4,,15
        .globl  testovf
        .type   testovf, @function
testovf:
.LFB0:
        .cfi_startproc
        xorl    %eax, %eax
        ret
        .cfi_endproc
.LFE0:
        .size   testovf, .-testovf
        .ident  "GCC: (GNU) 6.3.0"
        .section        .note.GNU-stack,"",@progbits

gcc -O2 -S -fwrapv test.c

"-fwrapv" allows twos-complement wrapping for signed arithmetic overflow. So the compiler actually evaluates the statement. It will be true for n>0 and false for n<=0.

        .file   "test.c"
        .text
        .p2align 4,,15
        .globl  testovf
        .type   testovf, @function
testovf:
.LFB0:
        .cfi_startproc
        movabsq $9223372036854775807, %rax
        addq    %rdi, %rax
        cmpq    %rax, %rdi
        setg    %al
        ret
        .cfi_endproc
.LFE0:
        .size   testovf, .-testovf
        .ident  "GCC: (GNU) 6.3.0"
        .section        .note.GNU-stack,"",@progbits

gcc -O2 -fsanitize=undefined -S test.c

"-fsanitize=undefined" gives a diagnostic message when undefined behavior occurs. So if n is positive, it will overflow, which is undefined, and will call for a diagnostic message. If n <=0, it will not overflow and will not call for a diagnostic message. The code uses JO (jump on overflow) to determine whether it overflowed.

.file   "test.c"
        .text
        .p2align 4,,15
        .globl  testovf
        .type   testovf, @function
testovf:
.LFB0:
        .cfi_startproc
        pushq   %rbp
        .cfi_def_cfa_offset 16
        .cfi_offset 6, -16
        pushq   %rbx
        .cfi_def_cfa_offset 24
        .cfi_offset 3, -24
        movabsq $9223372036854775807, %rdx
        movq    %rdi, %rbp
        movq    %rdi, %rbx
        subq    $8, %rsp
        .cfi_def_cfa_offset 32
        addq    %rdx, %rbp
        jo      .L6
.L2:
        cmpq    %rbp, %rbx
        setg    %al
        addq    $8, %rsp
        .cfi_remember_state
        .cfi_def_cfa_offset 24
        popq    %rbx
        .cfi_def_cfa_offset 16
        popq    %rbp
        .cfi_def_cfa_offset 8
        ret
.L6:
        .cfi_restore_state
        movq    %rdi, %rsi
        movl    $.Lubsan_data0, %edi
        call    __ubsan_handle_add_overflow
        jmp     .L2
        .cfi_endproc
.LFE0:
        .size   testovf, .-testovf
        .section        .rodata.str1.1,"aMS",@progbits,1
.LC0:
        .string "test.c"
        .data
        .align 16
        .type   .Lubsan_data0, @object
        .size   .Lubsan_data0, 24
.Lubsan_data0:
        .quad   .LC0
        .long   4
        .long   11
        .quad   .Lubsan_type0
        .align 2
        .type   .Lubsan_type0, @object
        .size   .Lubsan_type0, 15
.Lubsan_type0:
        .value  0
        .value  13
        .string "'long int'"
        .ident  "GCC: (GNU) 6.3.0"
        .section        .note.GNU-stack,"",@progbits